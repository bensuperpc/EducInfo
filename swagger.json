{
  "openapi": "3.0.1",
  "info": {
    "title": "CTS API 1.0",
    "description": "CTS Realtime API.<br />You must fill the username field of the Basic HTTP Auth Header with your token.<br />To get a token, connect to your <a href='https://www.cts-strasbourg.eu/fr/portail-open-data/' target='_blank'>open data account</a>.<br /><br />Please make good use of the API and do not make an excessive number of requests.<br />The stop-monitoring and estimated-timetable APIs contain the elements ValidUntil and ShortestPossibleCycle to help you determine when it may be useful to make a new request.<br />All APIs also return the cache-control HTTP header, letting you know how long the response can at least be considered valid. Any request made before the expiration of this period will return the same response.<br />In the event of an abusive request not respecting these rules, an HTTP error code may be returned.",
    "version": "1.0"
  },
  "paths": {
    "/v1/siri/2.0/estimated-timetable": {
      "get": {
        "tags": [
          "SIRI"
        ],
        "summary": "Estimated Timetable service is used to inform interested schedule information systems of the current status of all known VEHICLE JOURNEYs.\r\nAll VEHICLE JOURNEYs currently running and all those that start in the hour are returned.",
        "description": "A EstimatedTimetableDelivery is made up of EstimatedTimetableVersionFrame instances, each representing a schedule of DATED VEHICLE JOURNEY for a LINE and DIRECTION.\r\nEach production timetable is returned as an EstimatedTimetableVersionFrame element. Each Estimated-TimetableVersionFrame comprises one or more EstimatedVehicleJourney elements grouped for a version of the timetable.\r\nEach EstimatedVehicleJourney contains an ordered list of EstimatedCall elements, as well as other properties.\r\nEach EstimatedCall describes the estimated future times at a stop. A journey shall contain at least two CALLs of any type.\r\nExpectedDepartureTime is the value to show to the clients for real time application.\r\nPublishedLineName is the value to show to the client for the line number. It is more precise that LineRef.\r\nIf there is a VIA, you have to concatenante it with the DestinationName using the \"via\" keyword. Like \"[DestinationName] via [Via]\", eg. \"Neuhof St√©phanie via Stade Walter\".",
        "parameters": [
          {
            "name": "RequestorRef",
            "in": "query",
            "description": "Identifier of Requestor. May be used to identify an individual participant system or individual device client. If used for a device client should be an anonymous token, divulged with user consent.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "MessageIdentifier",
            "in": "query",
            "description": "Arbitrary identifier that may be given to message. Will be returned in response.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "VehicleMode",
            "in": "query",
            "description": "A method of transportation, possible values : bus, tram, undefined. Default = undefined.",
            "schema": {
              "$ref": "#/components/schemas/VehicleModeEnumeration"
            }
          },
          {
            "name": "PreviewInterval",
            "in": "query",
            "description": "Forward duration for which Stop Visits should be included, that is, interval before predicted arrival at the stop for which to include visits: only journeys which will arrive or depart within this time span will be returned. ISO-8601 duration format, eg: PT30M = 30 minutes. Default/maximum = 2 hours.",
            "schema": {
              "type": "string",
              "format": "date-span"
            }
          },
          {
            "name": "LineRef",
            "in": "query",
            "description": "Filter the results to include only Stop Visits for VEHICLEs for the given LINES.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "DirectionRef",
            "in": "query",
            "description": "Filter the results to include only visits for VEHICLEs going to the specified DIRECTION.\r\nA DIRECTION is a relative sense of traversal of a ROUTE (for example inbound/outbound, clockwise/anticlockwise).\r\nPossible values : 0 / 1\r\nEquivalent to the direction_id on trip trips.txt GTFS file.\r\nYou must use this value instead of the DestinationName for any favorits mechanisms.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "IncludeGeneralMessage",
            "in": "query",
            "description": "If true, GeneralMessageDelivery will be included (same as siri/2.0/general-message webservice)",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "IncludeFLUO67",
            "in": "query",
            "description": "If true, stop visits from FLUO67 vehicles will also be returned. Default = false.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "RemoveCheckOut",
            "in": "query",
            "description": "If true, \"old\" departures are not returned. Default = false",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "GetStopIdInsteadOfStopCode",
            "in": "query",
            "description": "If true : StopPointRef will be the stop_id of the GTFS, otherwise the stop_code. Default = false",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseEstimatedTimetableList"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseEstimatedTimetableList"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseEstimatedTimetableList"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseEstimatedTimetableList"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseEstimatedTimetableList"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, missing or wrong parameter",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "Technical error - Please try again later",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/siri/2.0/general-message": {
      "get": {
        "tags": [
          "SIRI"
        ],
        "summary": "Returns messages about traffic information, modify services, commercial information...",
        "description": "ItemIdentifier stay the same and is linked to the disruption.\r\nInfoMessageIdentifier change every time the disruption is updated.\r\nThe customer could be inform of a disruption before the ImpactStartDateTime, to anticipate the disruption. You can display the disruption as soon as you have it.\r\nIf you want to send notifications to customers : use Priority (and check instructions on SendUpdatedNotificationsToCustomers).",
        "parameters": [
          {
            "name": "RequestorRef",
            "in": "query",
            "description": "Identifier of Requestor. May be used to identify an individual participant system or individual device client. If used for a device client should be an anonymous token, divulged with user consent.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "MessageIdentifier",
            "in": "query",
            "description": "Arbitrary identifier that may be given to message. Will be returned in response.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "InfoChannelRef",
            "in": "query",
            "description": "Filter the results based on the InfoChannel to which message belongs. If empty you'll receive everything. Values can be Disruption, PlannedDisruption, Information, Works.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "LineRef",
            "in": "query",
            "description": "Filter the results to include only messages for the given LINEs.",
            "schema": {
              "maxItems": 2147483647,
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "ImpactedLineRef",
            "in": "query",
            "description": "Filter the results to include only messages for the given Impacted lines.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseGeneralMessageList"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseGeneralMessageList"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseGeneralMessageList"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseGeneralMessageList"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseGeneralMessageList"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, missing or wrong parameter",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "Technical error - Please try again later",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/siri/2.0/lines-discovery": {
      "get": {
        "tags": [
          "SIRI"
        ],
        "summary": "Returns a list of all lines",
        "description": "Use a cache and respect ValidUntil and ShortestPossibleCycle parameters.",
        "parameters": [
          {
            "name": "RequestorRef",
            "in": "query",
            "description": "Identifier of Requestor. May be used to identify an individual participant system or individual device client. If used for a device client should be an anonymous token, divulged with user consent.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "MessageIdentifier",
            "in": "query",
            "description": "Arbitrary identifier that may be given to message. Will be returned in response.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of active lines",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseLinesDiscoveryList"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseLinesDiscoveryList"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseLinesDiscoveryList"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseLinesDiscoveryList"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseLinesDiscoveryList"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, missing or wrong parameter",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "Technical error - Please try again later",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/cts/park-and-ride": {
      "get": {
        "tags": [
          "CTS"
        ],
        "summary": "Returns a list of park and ride with available spots",
        "description": "",
        "responses": {
          "200": {
            "description": "List of park and ride",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseParkAndRideList"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseParkAndRideList"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseParkAndRideList"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseParkAndRideList"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseParkAndRideList"
                }
              }
            }
          },
          "500": {
            "description": "Technical error - Please try again later",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/cts/retail-outlet": {
      "get": {
        "tags": [
          "CTS"
        ],
        "summary": "Returns a list of retail outlet",
        "description": "",
        "parameters": [
          {
            "name": "TicketSales",
            "in": "query",
            "description": "Filter retail outlets that sell tickets",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "BadgeoTopUp",
            "in": "query",
            "description": "Filter retail outlets that can top up Badg√©o cards",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "types",
            "in": "query",
            "description": "Filter retail outlets by type (comma separated list)",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "latitude",
            "in": "query",
            "description": "Use to get retail outlets around a coordinate. You muse provide latitude, longitude and distance to use it",
            "schema": {
              "type": "number",
              "format": "double"
            }
          },
          {
            "name": "longitude",
            "in": "query",
            "description": "Use to get retail outlets around a coordinate. You muse provide latitude, longitude and distance to use it",
            "schema": {
              "type": "number",
              "format": "double"
            }
          },
          {
            "name": "distance",
            "in": "query",
            "description": "Distance in meter around the latitude/longitude parameters. Use to get retail outlets around a coordinate. You muse provide latitude, longitude and distance to use it",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of retail outlet",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseRetailOutletList"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseRetailOutletList"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseRetailOutletList"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseRetailOutletList"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseRetailOutletList"
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "Technical error - Please try again later",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/cts/retail-outlet/types": {
      "get": {
        "tags": [
          "CTS"
        ],
        "summary": "Returns a list of retail outlet types",
        "description": "",
        "responses": {
          "200": {
            "description": "List of retail outlet types",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseRetailOutletType"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseRetailOutletType"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseRetailOutletType"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseRetailOutletType"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseRetailOutletType"
                }
              }
            }
          },
          "500": {
            "description": "Technical error - Please try again later",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/siri/2.0/stop-monitoring": {
      "get": {
        "tags": [
          "SIRI"
        ],
        "summary": "Stop Monitoring service provides a stop-centric view of VEHICLE departures (in realtime) at a list of designated stops.",
        "description": "A StopMonitoringDelivery is made up of MonitoredStopVisit instances, each representing a CALL at the SCHEDULED STOP POINT by a VEHICLE.\r\nEach MonitoredStopVisit contains a set of subelements describing the VEHICLE‚Äôs visit to the stop, including scheduled and/or real-time times, and also a MonitoredVehicleJourney element, which describes the VEHICLE‚Äôs route and associations with the DatedVehicleJourney that it follows, and other entities.\r\nExpectedDepartureTime is the value to show to the clients for real time application.\r\nPublishedLineName is the value to show to the client for the line number. It is more precise that LineRef.\r\nIf there is a VIA, you have to concatenate it with the DestinationName using the \"via\" keyword. Like \"[DestinationName] via [Via]\", eg. \"Neuhof St√©phanie via Stade Walter\".",
        "parameters": [
          {
            "name": "MonitoringRef",
            "in": "query",
            "description": "Reference to one or multiple Stop Monitoring point for which Stop Visits will be returned.\r\nRecommended values : StopCode or LogicalStopCode from stoppoints-discovery API.\r\nThe LogicalStopCode represent the whole stop (all directions), the StopCode represent the physical stop (\"one side\" of the road, precise direction).\r\nThe LogicalStopCode is the same as the StopCode but without the letter at the end, eg: 13A (StopCode) - 13 (LogicalStopCode).\r\nThe StopCode is the stop_code field on the GTFS stops.txt file.",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "RequestorRef",
            "in": "query",
            "description": "Identifier of Requestor. May be used to identify an individual participant system or individual device client. If used for a device client should be an anonymous token, divulged with user consent.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "MessageIdentifier",
            "in": "query",
            "description": "Arbitrary identifier that may be given to message. Will be returned in response.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "VehicleMode",
            "in": "query",
            "description": "A method of transportation, possible values : bus, tram, undefined. Default = undefined.",
            "schema": {
              "$ref": "#/components/schemas/VehicleModeEnumeration"
            }
          },
          {
            "name": "PreviewInterval",
            "in": "query",
            "description": "Forward duration for which Stop Visits should be included, that is, interval before predicted arrival at the stop for which to include visits: only journeys which will arrive or depart within this time span will be returned. ISO-8601 duration format, eg: PT30M = 30 minutes. Default/maximum = 1h30.",
            "schema": {
              "type": "string",
              "format": "date-span"
            }
          },
          {
            "name": "StartTime",
            "in": "query",
            "description": "Initial start time for PreviewInterval. If absent, then current time is assumed. Must be within data Horizon (max 1h30 from current time). ISO-8601 duration format, eg: 2017-02-08T13:45:50+01:00.",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "LineRef",
            "in": "query",
            "description": "Filter the results to include only Stop Visits for VEHICLEs for the given LINE.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "DirectionRef",
            "in": "query",
            "description": "Filter the results to include only visits for VEHICLEs going to the specified DIRECTION.\r\nA DIRECTION is a relative sense of traversal of a ROUTE (for example inbound/outbound, clockwise/anticlockwise).\r\nPossible values : 0 / 1\r\nEquivalent to the direction_id on trip trips.txt GTFS file.\r\nYou must use this value instead of the DestinationName for any favorits mechanisms.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "MaximumStopVisits",
            "in": "query",
            "description": "The maximum number of arrival or departure visits to include in a given delivery. The first n Stop Visits within the look-ahead window are included. Only visits within the PreviewInterval are returned. Default = 3.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "MinimumStopVisitsPerLine",
            "in": "query",
            "description": "The requested minimum number of arrival or departure visits to include in a given delivery. If there are more visits within the PreviewInterval than allowed by MaximumStopVisits, and a MinimumStopVisitsPerLine value is specified, then at least the minimum number will be delivered. That is, the first available visits within the PreviewInterval will be included, even if the Stop Visits are later than those for some other LINE for which the minimum number of Stop Visits has already been supplied. This allows the Consumer to obtain at least one entry for every available LINE with VEHICLEs approaching the stop. Only visits within the PreviewInterval are returned. Default = 3.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "IncludeGeneralMessage",
            "in": "query",
            "description": "If true, GeneralMessageDelivery will be included (same as siri/2.0/general-message webservice)",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "IncludeFLUO67",
            "in": "query",
            "description": "If true, stop visits from FLUO67 vehicles will also be returned. Default = false.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseStopMonitoringList"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseStopMonitoringList"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseStopMonitoringList"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseStopMonitoringList"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseStopMonitoringList"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, missing or wrong parameter",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "Technical error - Please try again later",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/siri/2.0/stoppoints-discovery": {
      "get": {
        "tags": [
          "SIRI"
        ],
        "summary": "Returns a list of stop points",
        "description": "You can use StopCode or LogicalStopCode to request stop-monitoring.",
        "parameters": [
          {
            "name": "RequestorRef",
            "in": "query",
            "description": "Identifier of Requestor. May be used to identify an individual participant system or individual device client. If used for a device client should be an anonymous token, divulged with user consent.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "MessageIdentifier",
            "in": "query",
            "description": "Arbitrary identifier that may be given to message. Will be returned in response.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "latitude",
            "in": "query",
            "description": "Use to get stops around a coordinate. You muse provide latitude, longitude and distance to use it",
            "schema": {
              "type": "number",
              "format": "double"
            }
          },
          {
            "name": "longitude",
            "in": "query",
            "description": "Use to get stops around a coordinate. You muse provide latitude, longitude and distance to use it",
            "schema": {
              "type": "number",
              "format": "double"
            }
          },
          {
            "name": "distance",
            "in": "query",
            "description": "Distance in meter around the latitude/longitude parameters. Use to get stops around a coordinate. You muse provide latitude, longitude and distance to use it",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "includeLinesDestinations",
            "in": "query",
            "description": "Use this paramater to get the lines passing at the stop and the destinations for each way",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "stopCode",
            "in": "query",
            "description": "Use this paramater to get informations. Will return all stops with the same logicalStopCode",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of stop points",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseStopPointsDiscoveryList"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseStopPointsDiscoveryList"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseStopPointsDiscoveryList"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseStopPointsDiscoveryList"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseStopPointsDiscoveryList"
                }
              }
            }
          },
          "400": {
            "description": "Bad request, missing or wrong parameter",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "Technical error - Please try again later",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/cts/timetable-file": {
      "get": {
        "tags": [
          "CTS"
        ],
        "summary": "Returns links to the timetables files for a stop",
        "description": "",
        "parameters": [
          {
            "name": "logicalStopCode",
            "in": "query",
            "description": "Logical stop code (as returned in stop-discovery)",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of timetables files",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseTimetablesFilesList"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseTimetablesFilesList"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseTimetablesFilesList"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseTimetablesFilesList"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseTimetablesFilesList"
                }
              }
            }
          },
          "500": {
            "description": "Technical error - Please try again later",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/v1/cts/veloparc": {
      "get": {
        "tags": [
          "CTS"
        ],
        "summary": "Returns a list of veloparc",
        "description": "",
        "responses": {
          "200": {
            "description": "List of veloparc",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseVeloparcList"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseVeloparcList"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseVeloparcList"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseVeloparcList"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseVeloparcList"
                }
              }
            }
          },
          "500": {
            "description": "Technical error - Please try again later",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AnnotatedDestinationStructure": {
        "type": "object",
        "properties": {
          "DirectionRef": {
            "type": "integer",
            "description": "A DIRECTION is a relative sense of traversal of a ROUTE (for example inbound/outbound, clockwise/anticlockwise).\r\nPossible values : 0 / 1\r\nEquivalent to the direction_id on trip trips.txt GTFS file.\r\nYou must use this value instead of the DestinationName for any favorits mechanisms.",
            "format": "int32"
          },
          "DestinationName": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The name of the possible destinations for a DirectionRef",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AnnotatedLineStructure": {
        "type": "object",
        "properties": {
          "LineRef": {
            "type": "string",
            "description": "Line identifier",
            "nullable": true
          },
          "LineName": {
            "type": "string",
            "description": "Commercial name of the Line",
            "nullable": true
          },
          "Destinations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AnnotatedDestinationStructure"
            },
            "description": "List of Direction and possible Destinations for each Direction",
            "nullable": true
          },
          "Extension": {
            "$ref": "#/components/schemas/ExtensionAnnotatedLineStructure"
          }
        },
        "additionalProperties": false
      },
      "AnnotatedStopPointStructure": {
        "type": "object",
        "properties": {
          "StopPointRef": {
            "type": "string",
            "description": "Unique reference of the stop",
            "nullable": true
          },
          "Lines": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AnnotatedLineStructure"
            },
            "description": "List of Lines which desserve this stop",
            "nullable": true
          },
          "Location": {
            "$ref": "#/components/schemas/Location"
          },
          "StopName": {
            "type": "string",
            "description": "Stop name",
            "nullable": true
          },
          "Extension": {
            "$ref": "#/components/schemas/ExtensionAnnotatedStopPointStructure"
          }
        },
        "additionalProperties": false
      },
      "CTSGeneralMessage": {
        "type": "object",
        "properties": {
          "ImpactStartDateTime": {
            "type": "string",
            "description": "Start datetime of the perturbation. If you receive this message, you should start displaying it, even if the perturbation as not started yet (to inform the users)\r\nThe period MessageText should be use instead of ImpactStartDateTime if you want to display dates to the user",
            "format": "date-time"
          },
          "ImpactEndDateTime": {
            "type": "string",
            "description": "End datetime of the perturbation, can be null if not know\r\nThe period MessageText should be use instead of ImpactStartDateTime if you want to display dates to the user",
            "format": "date-time",
            "nullable": true
          },
          "ImpactedGroupOfLinesRef": {
            "type": "string",
            "description": "Indicate that the message concern the whole network and not a list of Lines. Possible value : null or CTS.",
            "nullable": true
          },
          "ImpactedLineRef": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of impacted Lines. Can be null, in this case refers to ImpactedGroupOfLinesRef.",
            "nullable": true
          },
          "TypeOfPassengerEquipmentRef": {
            "type": "string",
            "description": "Type of equipment that should use this message. By default : WEB",
            "nullable": true
          },
          "Priority": {
            "$ref": "#/components/schemas/Priority"
          },
          "SendUpdatedNotificationsToCustomers": {
            "type": "boolean",
            "description": "Use this value to know if customers should be notified again when the message change (ie when the InfoMessageIdentifier change and the content change).\r\nThis flag is only used when a notification has already been send, to know if it should be send again when a upate happened.\r\nIf false : disruption should still be show on mobile app or website, but without new notification."
          },
          "Message": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Message"
            },
            "description": "List of messages",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "Driver": {
        "type": "object",
        "additionalProperties": false
      },
      "Error": {
        "type": "object",
        "properties": {
          "error": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "EstimatedCalls": {
        "type": "object",
        "properties": {
          "StopPointRef": {
            "type": "string",
            "description": "Contains short text or a number that uniquely identifies the stop for passengers. Same as StopCode on stoppoints-discovery",
            "nullable": true
          },
          "StopPointName": {
            "type": "string",
            "description": "Name of SCHEDULED STOP POINT",
            "nullable": true
          },
          "DestinationName": {
            "type": "string",
            "description": "The name of the destination of the journey; used to help identify the VEHICLE to the public",
            "nullable": true
          },
          "DestinationShortName": {
            "type": "string",
            "description": "Name or Number by which the LINE is known to the public, used for small screens",
            "nullable": true
          },
          "Via": {
            "type": "string",
            "description": "Description of a VIA point on a journey. If there is a VIA, you have to concatenante it with the DestinationName using the \"via\" keyword. Like \"[DestinationName] via [Via]\", eg. \"Neuhof St√©phanie via Stade Walter\"",
            "nullable": true
          },
          "ExpectedDepartureTime": {
            "type": "string",
            "description": "Time of departure of VEHICLE. Can be Estimated (realtime) or not (aimed, theorical)",
            "format": "date-time",
            "nullable": true
          },
          "ExpectedArrivalTime": {
            "type": "string",
            "description": "Estimated time of arrival of VEHICLE. Can be Estimated (realtime) or not (aimed, theorical)",
            "format": "date-time"
          },
          "Extension": {
            "$ref": "#/components/schemas/ExtensionEstimatedCalls"
          }
        },
        "additionalProperties": false
      },
      "EstimatedTimetableDelivery": {
        "type": "object",
        "properties": {
          "version": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "ResponseTimestamp": {
            "type": "string",
            "description": "Time response element was created",
            "format": "date-time"
          },
          "ValidUntil": {
            "type": "string",
            "description": "End of data horizon of the data producer. No need to request again before this date. You can also use the cache-control HTTP Header",
            "format": "date-time"
          },
          "ShortestPossibleCycle": {
            "type": "string",
            "description": "Minimum interval at which updates can be sent",
            "format": "date-span"
          },
          "EstimatedJourneyVersionFrame": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EstimatedTimetableVersionFrame"
            },
            "description": "Provides a schedule of DATED VEHICLE JOURNEY for a LINE and DIRECTION.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "EstimatedTimetableVersionFrame": {
        "type": "object",
        "properties": {
          "RecordedAtTime": {
            "type": "string",
            "description": "Time at which data was recorded",
            "format": "date-time"
          },
          "EstimatedVehicleJourney": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EstimatedVehicleJourney"
            },
            "description": "Provides real-time information about a VEHICLE JOURNEY along which a VEHICLE is running.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "EstimatedVehicleJourney": {
        "type": "object",
        "properties": {
          "LineRef": {
            "type": "string",
            "description": "Reference to a LINE, based on the route_id column of the routes.txt GTFS file.",
            "nullable": true
          },
          "DirectionRef": {
            "type": "integer",
            "description": "A DIRECTION is a relative sense of traversal of a ROUTE (for example inbound/outbound, clockwise/anticlockwise).\r\nPossible values : 0 / 1\r\nEquivalent to the direction_id on trip trips.txt GTFS file.\r\nYou must use this value instead of the DestinationName for any favorits mechanisms.",
            "format": "int32"
          },
          "FramedVehicleJourneyRef": {
            "$ref": "#/components/schemas/FramedVehicleJourneyRef"
          },
          "PublishedLineName": {
            "type": "string",
            "description": "Name or Number by which the LINE is known to the public. Should be use on screen instead of LineRef.",
            "nullable": true
          },
          "IsCompleteStopSequence": {
            "type": "boolean",
            "description": "Whether the above CALL sequence is complete, i.e. represents every CALL of the route and so can be used to replace a previous CALL sequence"
          },
          "EstimatedCalls": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EstimatedCalls"
            },
            "description": "Complete sequence of stops along the route path, in calling order",
            "nullable": true
          },
          "Extension": {
            "$ref": "#/components/schemas/ExtensionEstimatedVehicleJourney"
          }
        },
        "additionalProperties": false
      },
      "ExtensionAnnotatedLineStructure": {
        "type": "object",
        "properties": {
          "RouteType": {
            "$ref": "#/components/schemas/RouteModeEnumeration"
          },
          "RouteColor": {
            "type": "string",
            "description": "Hexadecimal value of the line color",
            "nullable": true
          },
          "RouteTextColor": {
            "type": "string",
            "description": "Hexadecimal value of the text line color",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ExtensionAnnotatedStopPointStructure": {
        "type": "object",
        "properties": {
          "StopCode": {
            "type": "string",
            "description": "Client stop code, recommendated to request the StopMonitoring API. This code identify the stop with a precise direction (\"one side\" of the road).",
            "nullable": true
          },
          "LogicalStopCode": {
            "type": "string",
            "description": "Client stop code, recommendated to request the StopMonitoring API. This code identify the stop with all directions.",
            "nullable": true
          },
          "IsFlexhopStop": {
            "type": "boolean",
            "description": "Indicates that this stop is served by the Flexhop service  https://www.cts-strasbourg.eu/fr/se-deplacer/transport-a-la-demande/"
          },
          "distance": {
            "type": "integer",
            "description": "Distance (in meter) between the coordinates indicated by the parameters latitude/longitude and the stop.\r\nValue only present if the latitude/longitude/distance parameters are used.",
            "format": "int32",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ExtensionEstimatedCalls": {
        "type": "object",
        "properties": {
          "IsRealTime": {
            "type": "boolean",
            "description": "Indicate if the departure and arrival time are realtime or not"
          },
          "IsCheckOut": {
            "type": "boolean",
            "description": "Indicate that the departure is \"old\" and should no longer be displayed (eg : the vehicle has passed)"
          },
          "DataSource": {
            "type": "string",
            "description": "System which produce the data",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ExtensionEstimatedVehicleJourney": {
        "type": "object",
        "properties": {
          "VehicleMode": {
            "$ref": "#/components/schemas/VehicleModeEnumeration"
          }
        },
        "additionalProperties": false
      },
      "ExtensionMonitoredCall": {
        "type": "object",
        "properties": {
          "IsRealTime": {
            "type": "boolean",
            "description": "Indicate if the departure and arrival time are realtime or not"
          },
          "DataSource": {
            "type": "string",
            "description": "System which produce the data",
            "nullable": true
          },
          "Experimentation": {
            "type": "string",
            "description": "If not null, indicates the current experiment in the vehicle",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "FramedVehicleJourneyRef": {
        "type": "object",
        "properties": {
          "DatedVehicleJourneySAERef": {
            "type": "string",
            "description": "A reference to the DATED VEHICLE JOURNEY that the VEHICLE is making. Dedicated to the SAE, cannot match the GTFS trips",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "GeneralMessageDelivery": {
        "type": "object",
        "properties": {
          "version": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "ResponseTimestamp": {
            "type": "string",
            "description": "Time response element was created",
            "format": "date-time"
          },
          "ShortestPossibleCycle": {
            "type": "string",
            "description": "Minimum interval at which updates can be sent",
            "format": "date-span"
          },
          "InfoMessage": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InfoMessage"
            },
            "description": "An informative message.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "InfoMessage": {
        "type": "object",
        "properties": {
          "formatRef": {
            "type": "string",
            "description": "Identifies the format of the content. The value will always be \"CTS\"",
            "nullable": true
          },
          "RecordedAtTime": {
            "type": "string",
            "description": "Time the message was recorded.",
            "format": "date-time"
          },
          "ItemIdentifier": {
            "type": "string",
            "description": "Identifier of the situation (can be used to reference it). All updates of a message will have the same ItemIdentifier.",
            "nullable": true
          },
          "InfoMessageIdentifier": {
            "type": "string",
            "description": "Unique identifier of the message. An update of a message will generate a new InfoMessageIdentifier.",
            "nullable": true
          },
          "InfoChannelRef": {
            "type": "string",
            "description": "InfoChannel to which message belongs. Value can be Disruption, PlannedDisruption, Works, Information.",
            "nullable": true
          },
          "ValidUntilTime": {
            "type": "string",
            "description": "Time until which message is valid. This is not the value to show to users for the end of the perturbation. This time can be updated. If the end is not know = end of the exploitation day.",
            "format": "date-time"
          },
          "Content": {
            "$ref": "#/components/schemas/CTSGeneralMessage"
          }
        },
        "additionalProperties": false
      },
      "Lang": {
        "enum": [
          "FR",
          "EN",
          "DE"
        ],
        "type": "string"
      },
      "LinesDelivery": {
        "type": "object",
        "properties": {
          "ResponseTimestamp": {
            "type": "string",
            "description": "Time response element was created",
            "format": "date-time"
          },
          "RequestMessageRef": {
            "type": "string",
            "description": "Reference to a unique message identifier associated with the request which gave rise to this response",
            "nullable": true
          },
          "ValidUntil": {
            "type": "string",
            "description": "End of data horizon of the data producer",
            "format": "date-time"
          },
          "ShortestPossibleCycle": {
            "type": "string",
            "description": "Minimum interval at which updates can be sent",
            "format": "date-span"
          },
          "AnnotatedLineRef": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AnnotatedLineStructure"
            },
            "description": "Delivery for Line Discovery Service",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "Location": {
        "type": "object",
        "properties": {
          "Longitude": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "Latitude": {
            "type": "number",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "Message": {
        "type": "object",
        "properties": {
          "MessageZoneRef": {
            "type": "string",
            "description": "Zone to use for this message. For the WEB, three possibility : title, details and period. The period MessageText should be use to displays dates to the user, instead of ImpactStartDateTime and ImpactEndDateTime",
            "nullable": true
          },
          "MessageText": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MessageText"
            },
            "description": "List of messages for each language",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "MessageText": {
        "type": "object",
        "properties": {
          "Value": {
            "type": "string",
            "description": "Content of the message",
            "nullable": true
          },
          "Lang": {
            "$ref": "#/components/schemas/Lang"
          }
        },
        "additionalProperties": false
      },
      "MonitoredCall": {
        "type": "object",
        "properties": {
          "StopPointName": {
            "type": "string",
            "description": "Name of SCHEDULED STOP POINT",
            "nullable": true
          },
          "StopCode": {
            "type": "string",
            "description": "Contains short text or a number that uniquely identifies the stop for passengers.",
            "nullable": true
          },
          "Order": {
            "type": "integer",
            "description": "Order number of the stop in the vehicle journey",
            "format": "int32",
            "nullable": true
          },
          "ExpectedDepartureTime": {
            "type": "string",
            "description": "Time of departure of VEHICLE. Can be Estimated (realtime) or not (aimed, theorical)",
            "format": "date-time",
            "nullable": true
          },
          "ExpectedArrivalTime": {
            "type": "string",
            "description": "Estimated time of arrival of VEHICLE. Can be Estimated (realtime) or not (aimed, theorical)",
            "format": "date-time"
          },
          "Extension": {
            "$ref": "#/components/schemas/ExtensionMonitoredCall"
          }
        },
        "additionalProperties": false
      },
      "MonitoredStopVisit": {
        "type": "object",
        "properties": {
          "RecordedAtTime": {
            "type": "string",
            "description": "Time at which data was recorded",
            "format": "date-time"
          },
          "MonitoringRef": {
            "type": "string",
            "description": "Reference to a Stop Monitoring point at which visits happen",
            "nullable": true
          },
          "StopCode": {
            "type": "string",
            "description": "Contains short text or a number that uniquely identifies the stop for passengers.",
            "nullable": true
          },
          "MonitoredVehicleJourney": {
            "$ref": "#/components/schemas/MonitoredVehicleJourney"
          }
        },
        "additionalProperties": false
      },
      "MonitoredVehicleJourney": {
        "type": "object",
        "properties": {
          "LineRef": {
            "type": "string",
            "description": "Reference to a LINE, based on the route_id column of the routes.txt GTFS file.",
            "nullable": true
          },
          "DirectionRef": {
            "type": "integer",
            "description": "A DIRECTION is a relative sense of traversal of a ROUTE (for example inbound/outbound, clockwise/anticlockwise).\r\nPossible values : 0 / 1\r\nEquivalent to the direction_id on trip trips.txt GTFS file.\r\nYou must use this value instead of the DestinationName for any favorits mechanisms.",
            "format": "int32"
          },
          "FramedVehicleJourneyRef": {
            "$ref": "#/components/schemas/FramedVehicleJourneyRef"
          },
          "VehicleMode": {
            "$ref": "#/components/schemas/VehicleModeEnumeration"
          },
          "PublishedLineName": {
            "type": "string",
            "description": "Name or Number by which the LINE is known to the public. Should be use on screen instead of LineRef.",
            "nullable": true
          },
          "DestinationName": {
            "type": "string",
            "description": "The name of the destination of the journey; used to help identify the VEHICLE to the public",
            "nullable": true
          },
          "DestinationShortName": {
            "type": "string",
            "description": "Name or Number by which the LINE is known to the public, used for small screens",
            "nullable": true
          },
          "Via": {
            "type": "string",
            "description": "Description of a VIA point on a journey. If there is a VIA, you have to concatenante it with the DestinationName using the \"via\" keyword. Like \"[DestinationName] via [Via]\", eg. \"Neuhof St√©phanie via Stade Walter\"",
            "nullable": true
          },
          "MonitoredCall": {
            "$ref": "#/components/schemas/MonitoredCall"
          },
          "PreviousCall": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreviousCall"
            },
            "description": "The PreviousCall element describes a list of CALL which has already been made in the MonitoredVehicleJourney.",
            "nullable": true
          },
          "OnwardCall": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OnwardCall"
            },
            "description": "The OnwardCall element describes a list of CALL which has still to be made in the MonitoredVehicleJourney.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "OnwardCall": {
        "type": "object",
        "properties": {
          "StopPointName": {
            "type": "string",
            "description": "Name of SCHEDULED STOP POINT",
            "nullable": true
          },
          "StopCode": {
            "type": "string",
            "description": "Contains short text or a number that uniquely identifies the stop for passengers.",
            "nullable": true
          },
          "Order": {
            "type": "integer",
            "description": "Order number of the stop in the vehicle journey",
            "format": "int32",
            "nullable": true
          },
          "ExpectedDepartureTime": {
            "type": "string",
            "description": "Time of departure of VEHICLE. Can be Estimated (realtime) or not (aimed, theorical)",
            "format": "date-time",
            "nullable": true
          },
          "ExpectedArrivalTime": {
            "type": "string",
            "description": "Estimated time of arrival of VEHICLE. Can be Estimated (realtime) or not (aimed, theorical)",
            "format": "date-time"
          }
        },
        "additionalProperties": false
      },
      "ParkAndRide": {
        "type": "object",
        "properties": {
          "Designation": {
            "type": "string",
            "description": "Designation of the park and ride",
            "nullable": true
          },
          "Longitude": {
            "type": "number",
            "description": "Longitude of the park and ride, WGS84 format",
            "format": "double"
          },
          "Latitude": {
            "type": "number",
            "description": "Latitude of the park and ride, WGS84 format",
            "format": "double"
          },
          "LastUpdate": {
            "type": "string",
            "description": "Last time the real time data was updated",
            "format": "date-time"
          },
          "TotalParkingSpots": {
            "type": "integer",
            "description": "Total spots on the park and ride",
            "format": "int32"
          },
          "AvailableParkingSpots": {
            "type": "integer",
            "description": "Current available spots on the park and ride",
            "format": "int32"
          },
          "Variation": {
            "type": "integer",
            "description": "Variation in the last 15 minutes",
            "format": "int32"
          },
          "Open": {
            "type": "boolean",
            "description": "Indicates if the park and ride is open or close"
          },
          "AccessInformation_EN": {
            "type": "string",
            "description": "Access informations in English",
            "nullable": true
          },
          "AccessInformation_FR": {
            "type": "string",
            "description": "Access informations in French",
            "nullable": true
          },
          "AccessInformation_DE": {
            "type": "string",
            "description": "Access informations in German",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PreviousCall": {
        "type": "object",
        "properties": {
          "StopPointName": {
            "type": "string",
            "description": "Name of SCHEDULED STOP POINT",
            "nullable": true
          },
          "StopCode": {
            "type": "string",
            "description": "Contains short text or a number that uniquely identifies the stop for passengers.",
            "nullable": true
          },
          "Order": {
            "type": "integer",
            "description": "Order number of the stop in the vehicle journey",
            "format": "int32",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "Priority": {
        "enum": [
          "Normal",
          "Urgent",
          "Extrem"
        ],
        "type": "string"
      },
      "ResponseEstimatedTimetableList": {
        "type": "object",
        "properties": {
          "ServiceDelivery": {
            "$ref": "#/components/schemas/ServiceDelivery"
          }
        },
        "additionalProperties": false
      },
      "ResponseGeneralMessageList": {
        "type": "object",
        "properties": {
          "ServiceDelivery": {
            "$ref": "#/components/schemas/ServiceDelivery"
          }
        },
        "additionalProperties": false
      },
      "ResponseLinesDiscoveryList": {
        "type": "object",
        "properties": {
          "LinesDelivery": {
            "$ref": "#/components/schemas/LinesDelivery"
          }
        },
        "additionalProperties": false
      },
      "ResponseParkAndRideList": {
        "type": "object",
        "properties": {
          "ParkAndRide": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ParkAndRide"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ResponseRetailOutletList": {
        "type": "object",
        "properties": {
          "RetailOutlet": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RetailOutlet"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ResponseRetailOutletType": {
        "type": "object",
        "properties": {
          "RetailOutletType": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RetailOutletType"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ResponseStopMonitoringList": {
        "type": "object",
        "properties": {
          "ServiceDelivery": {
            "$ref": "#/components/schemas/ServiceDelivery"
          }
        },
        "additionalProperties": false
      },
      "ResponseStopPointsDiscoveryList": {
        "type": "object",
        "properties": {
          "StopPointsDelivery": {
            "$ref": "#/components/schemas/StopPointsDelivery"
          }
        },
        "additionalProperties": false
      },
      "ResponseTimetablesFilesList": {
        "type": "object",
        "properties": {
          "TimetablesFiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TimetableFile"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ResponseVelhopList": {
        "type": "object",
        "properties": {
          "Velhop": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Velhop"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ResponseVeloparcList": {
        "type": "object",
        "properties": {
          "Veloparc": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Veloparc"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "RetailOutlet": {
        "type": "object",
        "properties": {
          "Designation": {
            "type": "string",
            "description": "Designation of the retail outlet",
            "nullable": true
          },
          "Address": {
            "type": "string",
            "description": "Address of the retail outlet",
            "nullable": true
          },
          "Longitude": {
            "type": "number",
            "description": "Longitude of the retail outlet, WGS84 format",
            "format": "double"
          },
          "Latitude": {
            "type": "number",
            "description": "Latitude of the retail outlet, WGS84 format",
            "format": "double"
          },
          "OpeningTimes": {
            "type": "string",
            "description": "Opening times of the retail outlet",
            "nullable": true
          },
          "RetailOutletType": {
            "type": "string",
            "description": "Retail outlet type",
            "nullable": true
          },
          "RetailOutletTypeId": {
            "type": "integer",
            "description": "Retail outlet type id",
            "format": "int32"
          },
          "TicketSales": {
            "type": "boolean",
            "description": "Indicates if the retail outlet sales tickets"
          },
          "BadgeoTopUp": {
            "type": "boolean",
            "description": "Indicates if the retail outlet can topup Badg√©o card"
          },
          "Services": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of services offered by the retail outlet",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "RetailOutletType": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "id of the retail outlet type",
            "format": "int32"
          },
          "type": {
            "type": "string",
            "description": "Name of the retail outlet type",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "RouteModeEnumeration": {
        "enum": [
          "bus",
          "tram",
          "undefined"
        ],
        "type": "string"
      },
      "ServiceDelivery": {
        "type": "object",
        "properties": {
          "ResponseTimestamp": {
            "type": "string",
            "description": "Time response element was created",
            "format": "date-time"
          },
          "RequestMessageRef": {
            "type": "string",
            "description": "Reference to a unique message identifier associated with the request which gave rise to this response",
            "nullable": true
          },
          "StopMonitoringDelivery": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StopMonitoringDelivery"
            },
            "description": "Delivery for Stop Monitoring Service",
            "nullable": true
          },
          "VehicleMonitoringDelivery": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VehicleMonitoringDelivery"
            },
            "description": "Delivery for Vehicle Monitoring Service",
            "nullable": true
          },
          "EstimatedTimetableDelivery": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EstimatedTimetableDelivery"
            },
            "description": "Delivery for Estimated Timetable Service",
            "nullable": true
          },
          "GeneralMessageDelivery": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GeneralMessageDelivery"
            },
            "description": "Delivery for General Message Service",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ServiceType": {
        "enum": [
          "store",
          "automaticStation",
          "storeAndAutomaticStation"
        ],
        "type": "string"
      },
      "StopMonitoringDelivery": {
        "type": "object",
        "properties": {
          "version": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "ResponseTimestamp": {
            "type": "string",
            "description": "Time response element was created",
            "format": "date-time"
          },
          "ValidUntil": {
            "type": "string",
            "description": "End of data horizon of the data producer. No need to request again before this date. You can also use the cache-control HTTP Header",
            "format": "date-time"
          },
          "ShortestPossibleCycle": {
            "type": "string",
            "description": "Minimum interval at which updates can be sent",
            "format": "date-span"
          },
          "MonitoringRef": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Reference to a Stop Monitoring point at which visits happen",
            "nullable": true
          },
          "MonitoredStopVisit": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MonitoredStopVisit"
            },
            "description": "A visit to a SCHEDULED STOP POINT by a VEHICLE as a departure",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "StopPointsDelivery": {
        "type": "object",
        "properties": {
          "ResponseTimestamp": {
            "type": "string",
            "description": "Time response element was created",
            "format": "date-time"
          },
          "RequestMessageRef": {
            "type": "string",
            "description": "Reference to a unique message identifier associated with the request which gave rise to this response",
            "nullable": true
          },
          "AnnotatedStopPointRef": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AnnotatedStopPointStructure"
            },
            "description": "Delivery for Stop Points Discovery Service",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TimetableFile": {
        "type": "object",
        "properties": {
          "Url": {
            "type": "string",
            "description": "URL to the timetables file",
            "nullable": true
          },
          "StopCode": {
            "type": "string",
            "description": "Client stop code, recommendated to request the StopMonitoring API. This code identify the stop with a precise direction (\"one side\" of the road).",
            "nullable": true
          },
          "LineRef": {
            "type": "string",
            "description": "Line identifier",
            "nullable": true
          },
          "DestinationName": {
            "type": "string",
            "description": "The destination name",
            "nullable": true
          },
          "StartValidity": {
            "type": "string",
            "description": "Start of validity of the timetable",
            "format": "date-time"
          },
          "EndValidity": {
            "type": "string",
            "description": "End of validity of the timetable",
            "format": "date-time"
          }
        },
        "additionalProperties": false
      },
      "VehicleActivity": {
        "type": "object",
        "properties": {
          "RecordedAtTime": {
            "type": "string",
            "format": "date-time"
          },
          "MonitoredVehicleJourney": {
            "$ref": "#/components/schemas/MonitoredVehicleJourney"
          }
        },
        "additionalProperties": false
      },
      "VehicleModeEnumeration": {
        "enum": [
          "bus",
          "tram",
          "coach",
          "undefined"
        ],
        "type": "string"
      },
      "VehicleMonitoringDelivery": {
        "type": "object",
        "properties": {
          "ResponseTimestamp": {
            "type": "string",
            "format": "date-time"
          },
          "ValidUntil": {
            "type": "string",
            "format": "date-time"
          },
          "ShortestPossibleCycle": {
            "type": "string",
            "format": "date-span"
          },
          "VehicleActivity": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VehicleActivity"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "Velhop": {
        "type": "object",
        "properties": {
          "Designation": {
            "type": "string",
            "description": "Designation of the velhop spot",
            "nullable": true
          },
          "Longitude": {
            "type": "number",
            "description": "Longitude of the velhop spot, WGS84 format",
            "format": "double"
          },
          "Latitude": {
            "type": "number",
            "description": "Latitude of the velhop spot, WGS84 format",
            "format": "double"
          },
          "StationID": {
            "type": "integer",
            "description": "Station id, is null if the velhop spot is not a station",
            "format": "int32",
            "nullable": true
          },
          "AvailableBikes": {
            "type": "integer",
            "description": "Available bikes, is null if the velhop spot is not a station",
            "format": "int32",
            "nullable": true
          },
          "AvailableFreeBikeSpots": {
            "type": "integer",
            "description": "Available bike spots, is null if the velhop spot is not a station",
            "format": "int32",
            "nullable": true
          },
          "TotalBikeSpots": {
            "type": "integer",
            "description": "Total bike spots, is null if the velhop spot is not a station",
            "format": "int32",
            "nullable": true
          },
          "BankCard": {
            "type": "boolean",
            "description": "Indicates if the automatic station accept bank card, is null if the velhop spot is not a station",
            "nullable": true
          },
          "AccessInformation_EN": {
            "type": "string",
            "description": "Access informations in English",
            "nullable": true
          },
          "AccessInformation_FR": {
            "type": "string",
            "description": "Access informations in French",
            "nullable": true
          },
          "AccessInformation_DE": {
            "type": "string",
            "description": "Access informations in German",
            "nullable": true
          },
          "ServiceType": {
            "$ref": "#/components/schemas/ServiceType"
          }
        },
        "additionalProperties": false
      },
      "Veloparc": {
        "type": "object",
        "properties": {
          "Designation": {
            "type": "string",
            "description": "Designation of the veloparc",
            "nullable": true
          },
          "Longitude": {
            "type": "number",
            "description": "Longitude of the veloparc, WGS84 format",
            "format": "double"
          },
          "Latitude": {
            "type": "number",
            "description": "Latitude of the veloparc, WGS84 format",
            "format": "double"
          },
          "AccessInformation_EN": {
            "type": "string",
            "description": "Access informations in English",
            "nullable": true
          },
          "AccessInformation_FR": {
            "type": "string",
            "description": "Access informations in French",
            "nullable": true
          },
          "AccessInformation_DE": {
            "type": "string",
            "description": "Access informations in German",
            "nullable": true
          }
        },
        "additionalProperties": false
      }
    }
  }
}